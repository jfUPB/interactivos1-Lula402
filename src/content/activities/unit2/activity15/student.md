#### Reflexión final
En esta unidad, aprendí a diseñar e implementar una máquina de estados para una bomba temporizada y un semáforo en MicroPython. Al principio, la idea de manejar estados y transiciones parecía sencilla, pero al probar el código encontré varios errores y tuve que analizar más a fondo cómo estaba estructurada la lógica. Me di cuenta de que pequeños detalles, como dónde inicializar variables o cómo manejar eventos como los botones y el acelerómetro, hacían una gran diferencia en el funcionamiento. También aprendí a usar ***utime.ticks_diff()*** para controlar la cuenta regresiva sin bloquear el programa y el manejo de intevalos, algo que puedo aplicar en futuros proyectos con temporización. Además, la actividad del semáforo fue clave para entender cómo funcionan las máquinas de estados, porque pude ver de forma más clara cómo se manejan las transiciones y el flujo del programa que va cambiando dependiendo de los eventos. Lo más dificil fue depurar el código, ya que a veces los errores no eran evidentes y tenía que hacer varias pruebas para entender qué estaba fallando. Sin embargo, este proceso me ayudó a desarrollar un pensamiento más analítico y a mejorar mi forma de estructurar el código. En el futuro, me gustaría seguir explorando el uso de máquinas de estado en proyectos más complejos. La metodología de aprendizaje basada en prueba y error me resultó útil porque me obligó a pensar bien en cada ajuste que hacía.

